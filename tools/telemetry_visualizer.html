<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pressence Telemetry Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #4ec9b0;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #1177bb;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status {
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .status.disconnected {
            background: #d73a49;
        }
        
        .status.connected {
            background: #28a745;
        }
        
        .status.waiting {
            background: #f9c513;
            color: #1e1e1e;
        }
        
        .info-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        
        .visualization-panel {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            flex: 1;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            border-radius: 4px;
        }
        
        .log-panel {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            flex: 1;
            min-height: 100px;
            max-height: 300px;
            overflow: hidden;
        }
        
        .raw-json-panel {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            min-width: 0;
            overflow: hidden;
        }
        
        .raw-json-panel h2 {
            margin-bottom: 10px;
            color: #4ec9b0;
            font-size: 16px;
        }
        
        .raw-json {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre;
            color: #ce9178;
        }
        
        .log-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .log-controls button {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .logs {
            flex: 1;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            overflow-y: auto;
            overflow-x: auto;
            min-height: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-all;
        }
        
        .info-panel {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .info-panel h2 {
            margin-bottom: 10px;
            color: #4ec9b0;
            font-size: 16px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }
        
        .info-label {
            color: #9cdcfe;
        }
        
        .info-value {
            color: #ce9178;
        }
        
        .legend-panel {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .legend-panel h2 {
            margin-bottom: 10px;
            color: #4ec9b0;
            font-size: 16px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 30px;
            height: 3px;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¹ Pressence Telemetry Visualizer</h1>
    
    <div class="controls">
        <button id="connectBtn">Connect to Serial Port</button>
        <div class="status disconnected" id="status">Disconnected</div>
    </div>
    
    <div class="info-row">
        <div class="info-panel">
            <h2>Telemetry Data</h2>
            <div class="info-grid" id="infoGrid">
                <span class="info-label">Status:</span>
                <span class="info-value">Waiting for data...</span>
            </div>
        </div>
        
        <div class="legend-panel">
            <h2>Legend</h2>
            <div style="margin-bottom: 10px; color: #9cdcfe; font-size: 12px;">
                <strong>Y-axis:</strong> Raw sensor reading (0 at bottom, auto-scaled max at top)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4ec9b0;"></div>
                <span>Current Reading (bar height = reading value)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ce9178;"></div>
                <span>Baseline Value (bottom reference)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f9c513;"></div>
                <span>Note OFF Threshold</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #d73a49;"></div>
                <span>Note ON Threshold</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(78, 201, 176, 0.3);"></div>
                <span>Note Active (background highlight)</span>
            </div>
        </div>
        
        <div class="raw-json-panel">
            <h2>Latest Telemetry JSON</h2>
            <div class="raw-json" id="rawJson">Waiting for data...</div>
        </div>
    </div>
    
    <div class="container">
        <div class="visualization-panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        
        <div class="log-panel">
            <div class="log-controls">
                <button id="clearLogsBtn">Clear Logs</button>
                <label>
                    <input type="checkbox" id="autoScrollCheckbox" checked>
                    Auto-scroll
                </label>
            </div>
            <div class="logs" id="logs"></div>
        </div>
    </div>
    
    <script>
        // Web Serial API setup
        let port = null;
        let reader = null;
        let keepReading = false;
        let reconnecting = false;
        
        // Visualization state
        let telemetryData = null;
        let audioStats = null;
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let persistentMaxValue = 10;  // Start at 10, only increases
        
        // UI elements
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const logsEl = document.getElementById('logs');
        const infoGridEl = document.getElementById('infoGrid');
        const clearLogsBtn = document.getElementById('clearLogsBtn');
        const autoScrollCheckbox = document.getElementById('autoScrollCheckbox');
        const rawJsonEl = document.getElementById('rawJson');
        
        // Connect/disconnect button handler
        connectBtn.addEventListener('click', async () => {
            if (port) {
                await disconnect();
            } else {
                await connect();
            }
        });
        
        clearLogsBtn.addEventListener('click', () => {
            logsEl.textContent = '';
        });
        
        // Connect to serial port
        async function connect() {
            // Request a port and open it
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            
            updateStatus('connected', 'Connected');
            connectBtn.textContent = 'Disconnect';
            
            // Start reading
            keepReading = true;
            reconnecting = false;
            readSerial();
        }
        
        // Disconnect from serial port
        async function disconnect() {
            keepReading = false;
            reconnecting = false;
            
            if (reader) {
                await reader.cancel();
                reader = null;
            }
            
            if (port) {
                await port.close();
                port = null;
            }
            
            updateStatus('disconnected', 'Disconnected');
            connectBtn.textContent = 'Connect to Serial Port';
        }
        
        // Read from serial port
        async function readSerial() {
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();
            
            let buffer = '';
            
            while (keepReading) {
                const { value, done } = await reader.read();
                
                if (done) {
                    break;
                }
                
                buffer += value;
                
                // Process complete lines
                let newlineIndex;
                while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                    const line = buffer.substring(0, newlineIndex).trim();
                    buffer = buffer.substring(newlineIndex + 1);
                    
                    if (line.length > 0) {
                        processLine(line);
                    }
                }
            }
        }
        
        // Process a single line of input
        function processLine(line) {
            // Try to parse as JSON (telemetry)
            if (line.startsWith('{')) {
                try {
                    const data = JSON.parse(line);
                    
                    // Check telemetry type using discriminator
                    if (data.type === 'keyScan') {
                        telemetryData = data;
                        
                        // Format JSON with arrays on single lines
                        const formatted = JSON.stringify(data, null, 2)
                            .replace(/\[\s+/g, '[')
                            .replace(/\s+\]/g, ']')
                            .replace(/,\s{5}(?=\S)/g, ', ');
                        rawJsonEl.textContent = formatted;
                        
                        updateInfo();
                        return;  // Don't log telemetry
                    } else if (data.type === 'audio') {
                        audioStats = data;
                        
                        // Format audio stats as readable log message
                        const msg = `Audio stats: loop[avg=${data.avgLoopTime} us, max=${data.maxLoopTime} us, budget=${data.bufferDuration} us] ` +
                                  `scan[${data.avgScanTime} us] render[${data.avgRenderTime} us] ` +
                                  `underruns=${data.underrunCount} partial=${data.partialWriteCount} core=${data.coreId}`;
                        addLog(msg);
                        return;
                    }
                    
                    // Valid JSON but not recognized telemetry type, log it
                    addLog(line);
                } catch (error) {
                    // JSON parse failed - corrupted/partial data from serial
                    console.error('JSON parse error:', error.message, 'Line:', line.substring(0, 100));
                    addLog(`[JSON Parse Error] ${line.substring(0, 100)}...`, true);
                }
                return;
            }
            
            // Not telemetry, add to logs
            addLog(line);
        }
        
        // Add a log message
        function addLog(message, isError = false) {
            const timestamp = new Date().toLocaleTimeString();
            const color = isError ? '#d73a49' : '#d4d4d4';
            logsEl.innerHTML += `<span style="color: #666;">[${timestamp}]</span> <span style="color: ${color};">${escapeHtml(message)}</span>\n`;
            
            if (autoScrollCheckbox.checked) {
                logsEl.scrollTop = logsEl.scrollHeight;
            }
        }
        
        // Update connection status
        function updateStatus(className, text) {
            statusEl.className = 'status ' + className;
            statusEl.textContent = text;
        }
        
        // Update info panel
        function updateInfo() {
            if (!telemetryData) return;
            
            let html = '';
            html += `<span class="info-label">Keys:</span><span class="info-value">${telemetryData.keyCount}</span>`;
            html += `<span class="info-label">Calibrated:</span><span class="info-value">${telemetryData.isCalibrated ? 'Yes' : 'No'}</span>`;
            html += `<span class="info-label">Note ON Threshold:</span><span class="info-value">${telemetryData.noteOnThreshold.toFixed(2)}</span>`;
            html += `<span class="info-label">Note OFF Threshold:</span><span class="info-value">${telemetryData.noteOffThreshold.toFixed(2)}</span>`;
            
            // Count active notes
            const activeNotes = telemetryData.noteStates ? telemetryData.noteStates.filter(s => s).length : 0;
            html += `<span class="info-label">Active Notes:</span><span class="info-value">${activeNotes}</span>`;
            
            infoGridEl.innerHTML = html;
        }
        
        // Render visualization
        function updateVisualization() {
            if (!telemetryData) {
                return;
            }
            
            // Validate telemetry data structure
            if (!telemetryData.readings || !Array.isArray(telemetryData.readings)) {
                console.error('Invalid telemetry: readings is not an array', telemetryData.readings);
                return;
            }
            if (!telemetryData.baselines || !Array.isArray(telemetryData.baselines)) {
                console.error('Invalid telemetry: baselines is not an array', telemetryData.baselines);
                return;
            }
            if (telemetryData.readings.length !== telemetryData.keyCount) {
                console.error('Mismatch: readings length', telemetryData.readings.length, 'vs keyCount', telemetryData.keyCount);
            }
            if (telemetryData.baselines.length !== telemetryData.keyCount) {
                console.error('Mismatch: baselines length', telemetryData.baselines.length, 'vs keyCount', telemetryData.keyCount);
            }
            
            // Update canvas size to match container
            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                console.error('Canvas container has zero size:', rect.width, 'x', rect.height);
                return;
            }
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const keyCount = telemetryData.keyCount;
            const padding = 40;
            const barWidth = (width - padding * 2) / keyCount;
            const barPadding = barWidth * 0.2;
            const maxHeight = height - padding * 2;
            
            // Clear canvas
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, width, height);
            
            // Find max value for scaling (starts at 10, only increases)
            let currentMax = 10;
            for (let i = 0; i < keyCount; i++) {
                const reading = telemetryData.readings[i];
                const baseline = telemetryData.baselines[i];
                if (baseline > 0) {
                    const noteOnThreshold = baseline * telemetryData.noteOnThreshold;
                    currentMax = Math.max(currentMax, reading, noteOnThreshold * 1.2);
                } else {
                    currentMax = Math.max(currentMax, reading);
                }
            }
            
            // Only increase max value, never decrease (sticky)
            if (currentMax > persistentMaxValue) {
                persistentMaxValue = currentMax;
            }
            const maxValue = persistentMaxValue;
            
            if (maxValue <= 0) {
                console.error('Invalid maxValue:', maxValue, '- all readings are zero or negative');
                return;
            }
            
            // Draw each key
            for (let i = 0; i < keyCount; i++) {
                const x = padding + i * barWidth;
                const reading = telemetryData.readings[i];
                const baseline = telemetryData.baselines[i];
                const ratio = telemetryData.ratios[i];
                const noteActive = telemetryData.noteStates[i];
                const aftertouch = telemetryData.aftertouchValues[i];
                
                if (isNaN(reading) || isNaN(baseline)) {
                    console.error(`Key ${i}: NaN detected - reading=${reading}, baseline=${baseline}`);
                    continue;
                }
                
                const noteOffThreshold = baseline * telemetryData.noteOffThreshold;
                const noteOnThreshold = baseline * telemetryData.noteOnThreshold;
                
                // Scale values to canvas height
                const scaleY = (value) => {
                    const normalized = value / maxValue;
                    return padding + maxHeight - (normalized * maxHeight);
                };
                
                // Highlight background if note is active
                if (noteActive) {
                    ctx.fillStyle = 'rgba(78, 201, 176, 0.15)';
                    ctx.fillRect(x, padding, barWidth, maxHeight);
                }
                
                // Draw baseline line
                const baselineY = scaleY(baseline);
                ctx.strokeStyle = '#ce9178';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, baselineY);
                ctx.lineTo(x + barWidth, baselineY);
                ctx.stroke();
                
                // Draw note OFF threshold line
                const noteOffY = scaleY(noteOffThreshold);
                ctx.strokeStyle = '#f9c513';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(x, noteOffY);
                ctx.lineTo(x + barWidth, noteOffY);
                ctx.stroke();
                
                // Draw note ON threshold line
                const noteOnY = scaleY(noteOnThreshold);
                ctx.strokeStyle = '#d73a49';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(x, noteOnY);
                ctx.lineTo(x + barWidth, noteOnY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw reading bar
                const readingY = scaleY(reading);
                const barHeight = padding + maxHeight - readingY;
                
                if (isNaN(barHeight) || barHeight < 0) {
                    console.error(`Key ${i}: Invalid barHeight=${barHeight}, readingY=${readingY}`);
                } else {
                    ctx.fillStyle = noteActive ? '#4ec9b0' : '#569cd6';
                    ctx.fillRect(x + barPadding, readingY, barWidth - barPadding * 2, barHeight);
                }
                
                // Draw key label
                ctx.fillStyle = '#d4d4d4';
                ctx.font = '12px Consolas';
                ctx.textAlign = 'center';
                ctx.fillText(`K${i}`, x + barWidth / 2, height - padding + 20);
                
                // Draw ratio value
                ctx.fillStyle = noteActive ? '#4ec9b0' : '#9cdcfe';
                ctx.font = '10px Consolas';
                const displayValue = (ratio !== null && !isNaN(ratio)) ? ratio.toFixed(2) : reading.toString();
                ctx.fillText(displayValue, x + barWidth / 2, readingY - 5);
                
                // Draw aftertouch value if note is active
                if (noteActive && aftertouch > 0) {
                    ctx.fillStyle = '#f9c513';
                    ctx.font = '10px Consolas';
                    ctx.fillText(`AT:${aftertouch}`, x + barWidth / 2, readingY - 18);
                }
            }
            
            // Draw title
            ctx.fillStyle = '#d4d4d4';
            ctx.font = '14px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Capacitive Key Scanner Readings', padding, 25);
            
            // Draw Y-axis scale info
            ctx.fillStyle = '#9cdcfe';
            ctx.font = '11px Consolas';
            ctx.textAlign = 'right';
            ctx.fillText(`Max: ${Math.round(maxValue)}`, padding - 5, padding + 10);
            ctx.fillText('0', padding - 5, padding + maxHeight);
            ctx.fillStyle = '#666';
            ctx.fillText('(raw sensor value)', padding - 5, padding + maxHeight / 2);
        }
        
        // Escape HTML for safe display
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Animation loop for smooth rendering
        function animate() {
            if (telemetryData) {
                updateVisualization();
            }
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (telemetryData) {
                updateVisualization();
            }
        });
        
        // Check for Web Serial API support
        if (!('serial' in navigator)) {
            addLog('Web Serial API not supported in this browser. Please use Chrome, Edge, or Opera.', true);
            connectBtn.disabled = true;
        }
    </script>
</body>
</html>
